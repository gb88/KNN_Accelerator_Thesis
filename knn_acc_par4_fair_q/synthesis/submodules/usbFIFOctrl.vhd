-- WARNING: Do NOT edit the input and output ports in this file in a text
-- editor if you plan to continue editing the block that represents it in
-- the Block Editor! File corruption is VERY likely to occur.

-- Copyright (C) 1991-2004 Altera Corporation
-- Any  megafunction  design,  and related netlist (encrypted  or  decrypted),
-- support information,  device programming or simulation file,  and any other
-- associated  documentation or information  provided by  Altera  or a partner
-- under  Altera's   Megafunction   Partnership   Program  may  be  used  only
-- to program  PLD  devices (but not masked  PLD  devices) from  Altera.   Any
-- other  use  of such  megafunction  design,  netlist,  support  information,
-- device programming or simulation file,  or any other  related documentation
-- or information  is prohibited  for  any  other purpose,  including, but not
-- limited to  modification,  reverse engineering,  de-compiling, or use  with
-- any other  silicon devices,  unless such use is  explicitly  licensed under
-- a separate agreement with  Altera  or a megafunction partner.  Title to the
-- intellectual property,  including patents,  copyrights,  trademarks,  trade
-- secrets,  or maskworks,  embodied in any such megafunction design, netlist,
-- support  information,  device programming or simulation file,  or any other
-- related documentation or information provided by  Altera  or a megafunction
-- partner, remains with Altera, the megafunction partner, or their respective
-- licensors. No other licenses, including any licenses needed under any third
-- party's intellectual property, are provided herein.


-- Generated by Quartus II Version 4.2 (Build Build 157 12/07/2004)
-- Created on Tue Apr 26 21:32:30 2005

LIBRARY ieee;
USE ieee.std_logic_1164.all;


--  Entity Declaration

ENTITY usbFIFOCtrl IS
	-- {{ALTERA_IO_BEGIN}} DO NOT REMOVE THIS LINE!
	PORT(
	-- Avalon
	clk,
	reset_n,
	read,
	write,
	chipselect	: in std_logic;
	byteenable: in std_logic_vector(1 downto 0);
	address		: in std_logic_vector(1 downto 0);
	readdata	: out std_logic_vector(15 downto 0);
	writedata	: in std_logic_vector(15 downto 0);
	
	-- FIFO FX2
	FIFO_wr_n,
	FIFO_rd_n,
	FIFO_oe_n,
	FIFO_pktend	: out std_logic;
	FIFO_add	: out std_logic_vector(1 downto 0);
	FIFO_data	: inout std_logic_vector(15 downto 0);
	FLAGB_n,
	FLAGC_n		: in std_logic;
	led: out std_logic_vector(2 downto 0)
	);
	-- {{ALTERA_IO_END}} DO NOT REMOVE THIS LINE!
	
END usbFIFOCtrl;

--  Architecture Body

ARCHITECTURE synth OF usbFIFOCtrl IS

type state_type is (IDLE, R0, R1, R2, W0, W1, PKTEND);
signal state, nextstate : state_type;

-- Registres:
-- add | reg name | access type
-- ----+----------+------------
-- 00  | data i/o | rw
-- 01  | status   | ro
-- 10  | control  | wo
-- 11  | address  | rw

-- data [15..0]
signal reg_data_in, nextreg_data_in, reg_data_out : std_logic_vector(15 downto 0);

--			|15..1|  0 |
-- status	|0...0|busy|
signal reg_busy : std_logic;

--			|15 .. 5|  2   | 1  |  0  |
-- control	|0 ... 0|commit|read|write|

signal reg_commit, reg_read, reg_write : std_logic;

--        |15...10| 9 | 8 |7 ... 2|1 ... 0|
-- fifos  |0 ... 0|B_n|C_n|0 ... 0|address|
--2 bit pour l'addresse de l'endpoint, et la valeur de FLAGB_n etFLAGC_n correspondant ï¿½ l'addresse
-- les flags sont uniquement accessible en lecture
signal reg_ep_address : std_logic_vector(1 downto 0);

BEGIN
-- bus avalon interface

reg_busy<='0' when nextstate=IDLE else '1';

process(clk, reset_n)
begin
	if(reset_n='0')then
		reg_commit<='0';
		reg_read<='0';
		reg_write<='0';
		readdata<=(others=>'0');
		reg_data_out<=(others=>'0');
		reg_ep_address<="00";	
	elsif(rising_edge(clk))then
		readdata<=(others=>'0');
		reg_write<='0';
		reg_read<='0';
		if(nextstate=IDLE)then
			reg_commit<='0';
		end if;
		led<="000";
		if(chipselect='1')then
			--read a register
		if(byteenable="11")then
			if(read='1')then
			--led<="000";
				case address is
				when "00" =>
					readdata<=reg_data_in;
				when "01" =>
					readdata(0)<= reg_busy;
				when "11" =>
					readdata(9)<=FLAGB_n;--not full
					readdata(8)<=FLAGC_n;--not empty
					readdata(1 downto 0)<=reg_ep_address;
				when others=>
				end case;
			end if;
			-- write in a register
			if(write='1')then
			
				if(reg_busy='0')then
					case address is
					when "00" =>
						reg_data_out<=writedata;
						led(0)<='1';
					when "10" =>
						if(writedata(1) /= writedata(0))then
							reg_commit<=writedata(2);
							reg_read<=writedata(1);
							reg_write<=writedata(0);
						end if;
						led(1)<='1';
					when "11" =>
						reg_ep_address<=writedata(1 downto 0);
						led(2)<='1';
					when others=>
					end case;
				end if;
			end if;
		end if;
		end if;
	end if;
end process;

-- fsm
process(reset_n, clk)
begin
	if(reset_n='0')then
		state<=IDLE;
		reg_data_in<=(others=>'0');
	elsif(rising_edge(clk))then
		state<=nextstate;
		reg_data_in<=nextreg_data_in;
	end if;
end process;

-- FIFO interface
FIFO_add <= reg_ep_address; 

process(state, reg_read, reg_write, reg_data_in, FLAGB_n, FLAGC_n, FIFO_data, reg_commit, reg_data_out)
begin
	nextstate <= state;
	
	FIFO_rd_n <= '1';
	FIFO_wr_n <='1';
	FIFO_oe_n <= '1';
	FIFO_pktend<='1';
	FIFO_data <= (others =>'Z');
	nextreg_data_in <= reg_data_in;
	case(state) is
	when IDLE =>
		if(reg_read = '1')then
			if(FLAGC_n='1')then
				nextstate<=R1;
			else
				nextstate<=R0;
			end if;
		elsif(reg_write='1')then
			if(FLAGB_n = '1')then
				nextstate<=W1;
			else
				nextstate<=W0;
			end if;
		elsif(reg_commit='1')then
			nextstate<=PKTEND;
		end if;
		
	--read
	when R0 =>-- wait until FIFO is not Empty
		if(FLAGC_n='1')then
			nextstate<=R1;
		end if;
	when R1 =>-- output enabled and read data
		FIFO_oe_n <= '0';
		nextreg_data_in <= FIFO_data;
		nextstate<=R2;
	when R2 =>-- commit to increment the FIFO pointer
		FIFO_rd_n <= '0';
		nextstate<=IDLE;
		
	--write
	when W0 =>-- wait until FIFO is not Full
		if(FLAGB_n = '1')then
			nextstate<=W1;
		end if;
	when W1 =>-- prepare data and increment FIFO pointer
			--FIFO_add <= reg_ep_address;
			FIFO_wr_n <='0';
			FIFO_data <= reg_data_out;
		--led(2)<='1';
		if(reg_commit='1')then
			FIFO_pktend<='0';
		end if;
		nextstate<=IDLE;
	when PKTEND =>-- packet end
		FIFO_pktend<='0';
		nextstate<=IDLE;
	when others =>
		nextstate<=IDLE;
	end case;
end process;
end synth;